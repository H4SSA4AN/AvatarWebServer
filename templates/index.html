<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Audio Recorder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            color: #333;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 1.1rem;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .left-panel {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 40px;
        }

        .right-panel {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 600px;
        }

        .controls-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .recording-controls, .parameter-controls {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
        }

        .musetalk-placeholder {
            text-align: center;
            color: #666;
            font-size: 1.5rem;
            font-weight: 600;
        }

        .server-config {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
            margin-bottom: 30px;
        }

        .server-input-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .server-input {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .server-input label {
            font-weight: 600;
            color: #333;
            font-size: 0.9rem;
        }

        .server-input input {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .server-input input:focus {
            outline: none;
            border-color: #007bff;
        }

        .server-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .btn-connect {
            background: #28a745;
            color: white;
        }

        .btn-connect:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .btn-disconnect {
            background: #dc3545;
            color: white;
        }

        .btn-disconnect:hover {
            background: #c82333;
            transform: translateY(-2px);
        }

        .section-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }

        .recording-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .btn-record {
            background: #dc3545;
            color: white;
        }

        .btn-record:hover {
            background: #c82333;
            transform: translateY(-2px);
        }

        .btn-record:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .btn-stop {
            background: #28a745;
            color: white;
        }

        .btn-stop:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .btn-stop:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .btn-save {
            background: #007bff;
            color: white;
        }

        .btn-save:hover {
            background: #0056b3;
            transform: translateY(-2px);
        }

        .btn-save:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .btn-webrtc {
            background: #6f42c1;
            color: white;
        }

        .btn-webrtc:hover {
            background: #5a32a3;
            transform: translateY(-2px);
        }

        .recording-status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .status-idle {
            background: #e9ecef;
            color: #6c757d;
        }

        .status-recording {
            background: #f8d7da;
            color: #721c24;
            animation: pulse 2s infinite;
        }

        .status-webrtc {
            background: #d1ecf1;
            color: #0c5460;
            animation: pulse 2s infinite;
        }

        .status-processing {
            background: #d1ecf1;
            color: #0c5460;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .parameter-group {
            margin-bottom: 20px;
        }

        .parameter-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .parameter-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .parameter-input:focus {
            outline: none;
            border-color: #007bff;
        }

        .parameter-range {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .range-slider {
            flex: 1;
        }

        .range-value {
            min-width: 60px;
            text-align: center;
            font-weight: 600;
            color: #007bff;
        }

        .audio-visualizer {
            width: 100%;
            height: 100px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .visualizer-canvas {
            width: 100%;
            height: 100%;
        }

        .recording-info {
            background: #e9ecef;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .recording-time {
            font-size: 1.2rem;
            font-weight: 600;
            color: #333;
        }

        .recording-size {
            color: #666;
            margin-top: 5px;
        }

        .connection-status {
            background: #e9ecef;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
            font-size: 0.9rem;
        }

        .connection-connected {
            background: #d4edda;
            color: #155724;
        }

        .connection-disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .message {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 600;
        }

        .message-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .message-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .message-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .webrtc-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #6f42c1;
        }

        .webrtc-info h3 {
            color: #6f42c1;
            margin-bottom: 10px;
        }

        .webrtc-info p {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .recording-mode-info {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #2196f3;
        }

        .recording-mode-info p {
            color: #333;
            font-size: 0.9rem;
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .recording-mode-info p:last-child {
            margin-bottom: 0;
        }

        @media (max-width: 768px) {
            .main-layout {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .controls-section {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .container {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎤 WebRTC Audio Recorder</h1>
            <p>Real-time audio recording with WebRTC and customizable parameters</p>
        </div>

                <div class="main-layout">
            <!-- Left Panel - Audio Recorder -->
            <div class="left-panel">
                <div class="controls-section">
                    <!-- Recording Controls -->
                    <div class="recording-controls">
                        <h2 class="section-title">🎙️ Recording Controls</h2>
                        
                        <div class="connection-status connection-disconnected" id="connectionStatus">
                            WebSocket: Disconnected
                        </div>

                        <div class="recording-status status-idle" id="recordingStatus">
                            Ready to record
                        </div>

                        <div class="recording-mode-info">
                            <p><strong>Record:</strong> Traditional recording - saves audio after stopping</p>
                            <p><strong>WebRTC:</strong> Real-time streaming - audio is streamed for later processing with FPS/batch size parameters</p>
                        </div>

                        <div class="recording-buttons">
                            <button class="btn btn-record" id="recordBtn" title="Traditional recording using MediaRecorder API">Record</button>
                            <button class="btn btn-webrtc" id="webrtcBtn" title="Real-time WebRTC streaming for later processing">WebRTC</button>
                            <button class="btn btn-stop" id="stopBtn" disabled>Stop</button>
                            <button class="btn btn-save" id="saveBtn" disabled>Save</button>
                        </div>

                        <div class="audio-visualizer">
                            <canvas class="visualizer-canvas" id="visualizer"></canvas>
                        </div>

                        <div class="recording-info" id="recordingInfo" style="display: none;">
                            <div class="recording-time" id="recordingTime">00:00</div>
                            <div class="recording-size" id="recordingSize">0 KB</div>
                        </div>

                        <div class="webrtc-info" id="webrtcInfo" style="display: none;">
                            <h3>WebRTC Connection</h3>
                            <p id="webrtcStatus">Initializing...</p>
                            <p id="webrtcStats">No data</p>
                        </div>
                    </div>

                    <!-- Parameter Controls -->
                    <div class="parameter-controls">
                        <h2 class="section-title">⚙️ Processing Parameters</h2>
                        
                        <div class="parameter-group">
                            <label class="parameter-label" for="fps">FPS (Frames Per Second)</label>
                            <div class="parameter-range">
                                <input type="range" id="fps" class="range-slider" min="1" max="60" value="30">
                                <span class="range-value" id="fpsValue">30</span>
                            </div>
                            <small style="color: #666; font-size: 0.8rem;">For later processing stage</small>
                        </div>

                        <div class="parameter-group">
                            <label class="parameter-label" for="batchSize">Batch Size</label>
                            <div class="parameter-range">
                                <input type="range" id="batchSize" class="range-slider" min="16" max="256" value="64" step="16">
                                <span class="range-value" id="batchSizeValue">64</span>
                            </div>
                            <small style="color: #666; font-size: 0.8rem;">For later processing stage</small>
                        </div>

                        <button class="btn btn-save" id="updateParamsBtn" style="width: 100%; margin-top: 20px;">
                            Update Processing Parameters
                        </button>
                    </div>
                </div>

                <!-- Server Configuration -->
                <div class="server-config">
                    <h2 class="section-title">🔗 Server Configuration</h2>
                    
                                         <div class="server-input-group">
                         <div class="server-input">
                             <label for="server1Url">Mini Omni 2 URL</label>
                             <input type="url" id="server1Url" placeholder="ws://localhost:8080" value="ws://localhost:8080">
                         </div>
                     </div>
                     
                     <div class="server-input-group">
                         <div class="server-input">
                             <label for="server2Url">Musetalk URL</label>
                             <input type="url" id="server2Url" placeholder="ws://localhost:8081" value="ws://localhost:8081">
                         </div>
                     </div>
                    
                    <div class="server-actions">
                        <button class="btn btn-connect" id="connectServer1Btn">Connect Mini Omni 2</button>
                        <button class="btn btn-connect" id="connectServer2Btn">Connect Musetalk</button>
                        <button class="btn btn-disconnect" id="disconnectAllBtn">Disconnect All</button>
                    </div>
                </div>

                <div id="messageContainer"></div>
            </div>

            <!-- Right Panel - Musetalk Stream -->
            <div class="right-panel">
                <div class="musetalk-placeholder">
                    Musetalk Stream Here
                </div>
            </div>
        </div>
    </div>

    <script>
        class WebRTCAudioRecorder {
            constructor() {
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.isRecording = false;
                this.isWebRTC = false;
                this.startTime = 0;
                this.recordingInterval = null;
                this.audioContext = null;
                this.analyser = null;
                this.microphone = null;
                this.visualizerCanvas = document.getElementById('visualizer');
                this.visualizerCtx = this.visualizerCanvas.getContext('2d');
                
                                 // WebRTC properties
                 this.peerConnection = null;
                 this.localStream = null;
                 this.sessionId = this.generateSessionId();
                 this.websocket = null;
                 this.webrtcStats = {
                     packetsReceived: 0,
                     bytesReceived: 0,
                     framesProcessed: 0
                 };
                 
                 // Server WebSocket connections
                 this.miniOmniWebSocket = null;
                 this.musetalkWebSocket = null;
                
                this.initializeElements();
                this.setupEventListeners();
                this.setupVisualizer();
                this.connectWebSocket();
            }

            generateSessionId() {
                return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            initializeElements() {
                this.recordBtn = document.getElementById('recordBtn');
                this.webrtcBtn = document.getElementById('webrtcBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.saveBtn = document.getElementById('saveBtn');
                this.recordingStatus = document.getElementById('recordingStatus');
                this.recordingInfo = document.getElementById('recordingInfo');
                this.recordingTime = document.getElementById('recordingTime');
                this.recordingSize = document.getElementById('recordingSize');
                this.messageContainer = document.getElementById('messageContainer');
                this.connectionStatus = document.getElementById('connectionStatus');
                this.webrtcInfo = document.getElementById('webrtcInfo');
                this.webrtcStatus = document.getElementById('webrtcStatus');
                this.webrtcStats = document.getElementById('webrtcStats');
                
                // Parameter elements
                this.fpsSlider = document.getElementById('fps');
                this.fpsValue = document.getElementById('fpsValue');
                this.batchSizeSlider = document.getElementById('batchSize');
                this.batchSizeValue = document.getElementById('batchSizeValue');
                this.updateParamsBtn = document.getElementById('updateParamsBtn');
                
                                 // Server configuration elements
                 this.server1Url = document.getElementById('server1Url');
                 this.server2Url = document.getElementById('server2Url');
                 this.connectServer1Btn = document.getElementById('connectServer1Btn');
                 this.connectServer2Btn = document.getElementById('connectServer2Btn');
                 this.disconnectAllBtn = document.getElementById('disconnectAllBtn');
            }

            setupEventListeners() {
                this.recordBtn.addEventListener('click', () => this.startRecording());
                this.webrtcBtn.addEventListener('click', () => this.startWebRTC());
                this.stopBtn.addEventListener('click', () => this.stopRecording());
                this.saveBtn.addEventListener('click', () => this.saveRecording());
                this.updateParamsBtn.addEventListener('click', () => this.updateParameters());

                // Server connection listeners
                this.connectServer1Btn.addEventListener('click', () => this.connectToServer(1));
                this.connectServer2Btn.addEventListener('click', () => this.connectToServer(2));
                this.disconnectAllBtn.addEventListener('click', () => this.disconnectAllServers());

                // Parameter range listeners
                this.fpsSlider.addEventListener('input', (e) => {
                    this.fpsValue.textContent = e.target.value;
                });

                this.batchSizeSlider.addEventListener('input', (e) => {
                    this.batchSizeValue.textContent = e.target.value;
                });
            }

            setupVisualizer() {
                this.visualizerCanvas.width = this.visualizerCanvas.offsetWidth;
                this.visualizerCanvas.height = this.visualizerCanvas.offsetHeight;
            }

            async connectWebSocket() {
                try {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws`;
                    
                    this.websocket = new WebSocket(wsUrl);
                    
                    this.websocket.onopen = () => {
                        this.connectionStatus.textContent = 'WebSocket: Connected';
                        this.connectionStatus.className = 'connection-status connection-connected';
                        
                        // Send initialization message
                        this.websocket.send(JSON.stringify({
                            type: 'init',
                            session_id: this.sessionId
                        }));
                    };
                    
                    this.websocket.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.handleWebSocketMessage(data);
                    };
                    
                    this.websocket.onclose = () => {
                        this.connectionStatus.textContent = 'WebSocket: Disconnected';
                        this.connectionStatus.className = 'connection-status connection-disconnected';
                    };
                    
                    this.websocket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.showMessage('WebSocket connection error', 'error');
                    };
                    
                } catch (error) {
                    console.error('Error connecting to WebSocket:', error);
                    this.showMessage('Failed to connect to WebSocket', 'error');
                }
            }

            handleWebSocketMessage(data) {
                switch (data.type) {
                    case 'init_ack':
                        this.showMessage('WebSocket connection established', 'success');
                        break;
                    case 'audio_processed':
                        this.updateWebRTCStats(data.processed);
                        break;
                    case 'params_updated':
                        this.showMessage('Parameters updated via WebSocket', 'info');
                        break;
                    case 'pong':
                        // Handle ping-pong for connection health
                        break;
                }
            }

            async startRecording() {
                if (this.isWebRTC) {
                    this.showMessage('Please stop WebRTC recording first', 'error');
                    return;
                }

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: 44100,  // Fixed sample rate
                            channelCount: 1,    // Fixed mono channel
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        } 
                    });

                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    this.microphone = this.audioContext.createMediaStreamSource(stream);
                    
                    this.analyser.fftSize = 256;
                    this.microphone.connect(this.analyser);

                    this.mediaRecorder = new MediaRecorder(stream);
                    this.audioChunks = [];

                    this.mediaRecorder.ondataavailable = (event) => {
                        this.audioChunks.push(event.data);
                    };

                    this.mediaRecorder.onstop = () => {
                        this.isRecording = false;
                        this.updateUI();
                        this.stopVisualizer();
                    };

                    this.mediaRecorder.start();
                    this.isRecording = true;
                    this.startTime = Date.now();
                    this.updateUI();
                    this.startVisualizer();
                    this.startTimer();

                    this.showMessage('Recording started successfully!', 'success');

                } catch (error) {
                    console.error('Error starting recording:', error);
                    this.showMessage('Error starting recording: ' + error.message, 'error');
                }
            }

            async startWebRTC() {
                if (this.isRecording) {
                    this.showMessage('Please stop current recording first', 'error');
                    return;
                }

                try {
                    this.localStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            sampleRate: 44100,  // Fixed sample rate
                            channelCount: 1,    // Fixed mono channel
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });

                    // Create RTCPeerConnection
                    this.peerConnection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' }
                        ]
                    });

                    // Add local stream
                    this.localStream.getTracks().forEach(track => {
                        this.peerConnection.addTrack(track, this.localStream);
                    });

                    // Handle incoming audio data
                    this.peerConnection.ontrack = (event) => {
                        this.handleIncomingAudio(event);
                    };

                    // Create offer
                    const offer = await this.peerConnection.createOffer();
                    await this.peerConnection.setLocalDescription(offer);

                    // Send offer to server
                    const response = await fetch('/webrtc/offer', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            offer: offer,
                            session_id: this.sessionId
                        })
                    });

                    const result = await response.json();
                    
                    if (result.status === 'success') {
                        this.isWebRTC = true;
                        this.isRecording = true;
                        this.startTime = Date.now();
                        this.updateUI();
                        this.startTimer();
                        this.webrtcInfo.style.display = 'block';
                        this.webrtcStatus.textContent = 'WebRTC: Connected';
                        
                        this.showMessage('WebRTC recording started!', 'success');
                    } else {
                        this.showMessage('Error starting WebRTC: ' + result.message, 'error');
                    }

                } catch (error) {
                    console.error('Error starting WebRTC:', error);
                    this.showMessage('Error starting WebRTC: ' + error.message, 'error');
                }
            }

            handleIncomingAudio(event) {
                // Process incoming audio data with current parameters
                const audioData = event.streams[0];
                
                // Send audio data to server via WebSocket
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    this.websocket.send(JSON.stringify({
                        type: 'audio_data',
                        audio_data: 'audio_data_placeholder', // In real implementation, encode actual audio
                        session_id: this.sessionId,
                        timestamp: Date.now()
                    }));
                }
            }

            updateWebRTCStats(processed) {
                this.webrtcStats.packetsReceived++;
                this.webrtcStats.framesProcessed = processed.fps_applied;
                
                document.getElementById('webrtcStats').textContent = 
                    `Packets: ${this.webrtcStats.packetsReceived} | FPS: ${processed.fps_applied} | Batch: ${processed.batch_size_applied}`;
            }

                         async stopRecording() {
                 if (this.mediaRecorder && this.isRecording && !this.isWebRTC) {
                     this.mediaRecorder.stop();
                     this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
                     
                     if (this.audioContext) {
                         this.audioContext.close();
                     }
                     
                     clearInterval(this.recordingInterval);
                     this.showMessage('Recording stopped!', 'success');
                     
                     // Transmit audio to Mini Omni 2 if connected
                     await this.transmitAudioToMiniOmni2();
                     
                 } else if (this.isWebRTC) {
                     // Stop WebRTC recording
                     if (this.peerConnection) {
                         this.peerConnection.close();
                         this.peerConnection = null;
                     }
                     
                     if (this.localStream) {
                         this.localStream.getTracks().forEach(track => track.stop());
                         this.localStream = null;
                     }
                     
                     this.isWebRTC = false;
                     this.isRecording = false;
                     this.updateUI();
                     this.webrtcInfo.style.display = 'none';
                     clearInterval(this.recordingInterval);
                     
                     this.showMessage('WebRTC recording stopped!', 'success');
                     
                     // Transmit audio to Mini Omni 2 if connected
                     await this.transmitAudioToMiniOmni2();
                 }
             }

            async saveRecording() {
                if (this.audioChunks.length === 0 && !this.isWebRTC) {
                    this.showMessage('No recording to save!', 'error');
                    return;
                }

                try {
                    let audioBlob;
                    if (this.isWebRTC) {
                        // For WebRTC, we might not have audioChunks, so create a placeholder
                        audioBlob = new Blob(['webrtc_audio_data'], { type: 'audio/wav' });
                    } else {
                        audioBlob = new Blob(this.audioChunks, { type: 'audio/wav' });
                    }
                    
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    const base64Audio = this.arrayBufferToBase64(arrayBuffer);

                    const recordingData = {
                        audio_data: base64Audio,
                        duration: (Date.now() - this.startTime) / 1000,
                        session_id: this.sessionId,
                        recording_type: this.isWebRTC ? 'webrtc' : 'mediarecorder'
                    };

                    const response = await fetch('/save_recording', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(recordingData)
                    });

                    const result = await response.json();
                    
                    if (result.status === 'success') {
                        this.showMessage(`Recording saved as ${result.filename}`, 'success');
                        this.audioChunks = [];
                        this.updateUI();
                    } else {
                        this.showMessage('Error saving recording: ' + result.message, 'error');
                    }

                } catch (error) {
                    console.error('Error saving recording:', error);
                    this.showMessage('Error saving recording: ' + error.message, 'error');
                }
            }

            async updateParameters() {
                const params = {
                    fps: parseInt(this.fpsSlider.value),
                    batch_size: parseInt(this.batchSizeSlider.value),
                    sample_rate: 44100,  // Fixed sample rate
                    channels: 1          // Fixed mono channel
                };

                try {
                    // Update via HTTP
                    const response = await fetch('/update_params', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(params)
                    });

                    const result = await response.json();
                    
                    if (result.status === 'success') {
                        this.showMessage('Parameters updated successfully!', 'success');
                        
                        // Also update via WebSocket if connected
                        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                            this.websocket.send(JSON.stringify({
                                type: 'update_params',
                                params: params
                            }));
                        }
                    } else {
                        this.showMessage('Error updating parameters: ' + result.message, 'error');
                    }

                } catch (error) {
                    console.error('Error updating parameters:', error);
                    this.showMessage('Error updating parameters: ' + error.message, 'error');
                }
            }

            updateUI() {
                this.recordBtn.disabled = this.isRecording;
                this.webrtcBtn.disabled = this.isRecording;
                this.stopBtn.disabled = !this.isRecording;
                this.saveBtn.disabled = this.audioChunks.length === 0 && !this.isWebRTC;

                if (this.isRecording) {
                    if (this.isWebRTC) {
                        this.recordingStatus.textContent = 'WebRTC Recording...';
                        this.recordingStatus.className = 'recording-status status-webrtc';
                    } else {
                        this.recordingStatus.textContent = 'Recording...';
                        this.recordingStatus.className = 'recording-status status-recording';
                    }
                    this.recordingInfo.style.display = 'block';
                } else {
                    this.recordingStatus.textContent = 'Ready to record';
                    this.recordingStatus.className = 'recording-status status-idle';
                    this.recordingInfo.style.display = 'none';
                }
            }

            startTimer() {
                this.recordingInterval = setInterval(() => {
                    const elapsed = Date.now() - this.startTime;
                    const minutes = Math.floor(elapsed / 60000);
                    const seconds = Math.floor((elapsed % 60000) / 1000);
                    this.recordingTime.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    
                    // Update recording size
                    if (!this.isWebRTC) {
                        const totalSize = this.audioChunks.reduce((total, chunk) => total + chunk.size, 0);
                        this.recordingSize.textContent = `${(totalSize / 1024).toFixed(1)} KB`;
                    } else {
                        this.recordingSize.textContent = 'WebRTC Stream';
                    }
                }, 1000);
            }

            startVisualizer() {
                if (!this.analyser) return;
                
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                const draw = () => {
                    if (!this.isRecording) return;

                    requestAnimationFrame(draw);
                    this.analyser.getByteFrequencyData(dataArray);

                    this.visualizerCtx.fillStyle = 'rgb(248, 249, 250)';
                    this.visualizerCtx.fillRect(0, 0, this.visualizerCanvas.width, this.visualizerCanvas.height);

                    const barWidth = (this.visualizerCanvas.width / bufferLength) * 2.5;
                    let barHeight;
                    let x = 0;

                    for (let i = 0; i < bufferLength; i++) {
                        barHeight = dataArray[i] / 2;
                        this.visualizerCtx.fillStyle = `rgb(${barHeight + 100}, 50, 50)`;
                        this.visualizerCtx.fillRect(x, this.visualizerCanvas.height - barHeight, barWidth, barHeight);
                        x += barWidth + 1;
                    }
                };

                draw();
            }

            stopVisualizer() {
                this.visualizerCtx.fillStyle = 'rgb(248, 249, 250)';
                this.visualizerCtx.fillRect(0, 0, this.visualizerCanvas.width, this.visualizerCanvas.height);
            }

            arrayBufferToBase64(buffer) {
                let binary = '';
                const bytes = new Uint8Array(buffer);
                const len = bytes.byteLength;
                for (let i = 0; i < len; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return window.btoa(binary);
            }

                         async transmitAudioToMiniOmni2() {
                 try {
                     // Prepare audio data
                     let audioBlob;
                     if (this.isWebRTC) {
                         // For WebRTC, create a placeholder blob (in real implementation, you'd have actual audio data)
                         audioBlob = new Blob(['webrtc_audio_data'], { type: 'audio/wav' });
                     } else {
                         // For MediaRecorder, use the recorded chunks
                         if (this.audioChunks.length === 0) {
                             this.showMessage('No audio data to transmit', 'error');
                             return;
                         }
                         audioBlob = new Blob(this.audioChunks, { type: 'audio/wav' });
                     }
                     
                     // Convert to base64
                     const arrayBuffer = await audioBlob.arrayBuffer();
                     const base64Audio = this.arrayBufferToBase64(arrayBuffer);
                     
                     // Get current processing parameters
                     const processingParams = {
                         fps: parseInt(this.fpsSlider.value),
                         batch_size: parseInt(this.batchSizeSlider.value)
                     };
                     
                     // Prepare transmission data
                     const transmissionData = {
                         type: 'audio_processing_request',
                         audio_data: base64Audio,
                         audio_format: 'wav',
                         sample_rate: 44100,
                         channels: 1,
                         duration: (Date.now() - this.startTime) / 1000,
                         processing_parameters: processingParams,
                         session_id: this.sessionId,
                         timestamp: Date.now()
                     };
                     
                     // Get Mini Omni 2 URL and extract host and port
                     const miniOmniUrl = this.server1Url.value.trim();
                     let miniOmniHost, miniOmniPort;
                     
                     if (miniOmniUrl.startsWith('ws://') || miniOmniUrl.startsWith('wss://')) {
                         // Extract host and port from WebSocket URL
                         const url = new URL(miniOmniUrl);
                         miniOmniHost = url.hostname;
                         miniOmniPort = url.port || (url.protocol === 'wss:' ? '443' : '80');
                     } else {
                         // Assume it's a direct host:port format
                         const parts = miniOmniUrl.split(':');
                         miniOmniHost = parts[0];
                         miniOmniPort = parts[1] || '80';
                     }
                     
                     // Determine protocol based on port
                     const protocol = miniOmniPort === '443' ? 'https:' : 'http:';
                     
                     // Send to Mini Omni 2 via HTTP POST
                     const response = await fetch(`${protocol}//${miniOmniHost}:${miniOmniPort}/process_audio_json`, {
                         method: 'POST',
                         headers: {
                             'Content-Type': 'application/json',
                         },
                         body: JSON.stringify(transmissionData)
                     });
                     
                     if (response.ok) {
                         const result = await response.json();
                         this.showMessage('Audio transmitted to Mini Omni 2 for processing', 'success');
                         
                         // Handle response from Mini Omni 2
                         if (result.status === 'processing') {
                             this.showMessage(`Mini Omni 2: Processing audio (${result.progress || 0}%)`, 'info');
                         } else if (result.status === 'complete') {
                             this.showMessage('Mini Omni 2: Processing complete!', 'success');
                         } else if (result.status === 'error') {
                             this.showMessage(`Mini Omni 2 processing failed: ${result.error}`, 'error');
                         }
                     } else {
                         throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                     }
                     
                 } catch (error) {
                     console.error('Error transmitting audio to Mini Omni 2:', error);
                     this.showMessage('Error transmitting audio to Mini Omni 2: ' + error.message, 'error');
                 }
             }
             
             showMessage(message, type) {
                 const messageDiv = document.createElement('div');
                 messageDiv.className = `message message-${type}`;
                 messageDiv.textContent = message;
                 
                 this.messageContainer.appendChild(messageDiv);
                 
                 setTimeout(() => {
                     messageDiv.remove();
                 }, 5000);
             }

                         async connectToServer(serverNumber) {
                 const url = serverNumber === 1 ? this.server1Url.value : this.server2Url.value;
                 const serverName = serverNumber === 1 ? 'Mini Omni 2' : 'Musetalk';
                 
                 if (!url) {
                     this.showMessage(`Please enter a URL for ${serverName}`, 'error');
                     return;
                 }

                 try {
                     // Validate URL format
                     let wsUrl = url.trim();
                     
                     // If no protocol specified, default to ws://
                     if (!wsUrl.startsWith('ws://') && !wsUrl.startsWith('wss://')) {
                         wsUrl = 'ws://' + wsUrl;
                     }
                     
                     // Basic URL validation
                     try {
                         new URL(wsUrl);
                     } catch (e) {
                         this.showMessage(`Invalid URL format for ${serverName}. Please enter a valid WebSocket URL`, 'error');
                         return;
                     }

                     const button = serverNumber === 1 ? this.connectServer1Btn : this.connectServer2Btn;
                     button.textContent = 'Connecting...';
                     button.disabled = true;

                     // Create actual WebSocket connection
                     const serverWebSocket = new WebSocket(wsUrl);
                     
                                           // Set connection timeout
                      const connectionTimeout = setTimeout(() => {
                          if (serverWebSocket.readyState === WebSocket.CONNECTING) {
                              serverWebSocket.close();
                              this.showMessage(`Connection timeout to ${serverName} (${wsUrl})`, 'error');
                              button.textContent = serverNumber === 1 ? 'Connect Mini Omni 2' : 'Connect Musetalk';
                              button.disabled = false;
                          }
                      }, 5000); // 5 second timeout

                                           serverWebSocket.onopen = () => {
                          clearTimeout(connectionTimeout);
                          this.showMessage(`Successfully connected to ${serverName} (${wsUrl})`, 'success');
                         
                         button.textContent = 'Connected';
                         button.style.background = '#28a745';
                         
                         // Store the WebSocket connection
                         if (serverNumber === 1) {
                             this.miniOmniWebSocket = serverWebSocket;
                         } else {
                             this.musetalkWebSocket = serverWebSocket;
                         }
                         
                         // Send initial message
                         serverWebSocket.send(JSON.stringify({
                             type: 'init',
                             client: 'WebRTC Audio Recorder',
                             timestamp: Date.now()
                         }));
                     };
                     
                     serverWebSocket.onmessage = (event) => {
                         try {
                             const data = JSON.parse(event.data);
                             this.handleServerMessage(data, serverName);
                         } catch (error) {
                             console.log(`Raw message from ${serverName}:`, event.data);
                         }
                     };
                     
                     serverWebSocket.onclose = (event) => {
                         clearTimeout(connectionTimeout);
                         if (event.code !== 1000) { // Not a normal closure
                             this.showMessage(`Disconnected from ${serverName}: ${event.reason || 'Connection closed'}`, 'info');
                         }
                         
                         button.textContent = serverNumber === 1 ? 'Connect Mini Omni 2' : 'Connect Musetalk';
                         button.disabled = false;
                         button.style.background = '';
                         
                         // Clear the stored WebSocket
                         if (serverNumber === 1) {
                             this.miniOmniWebSocket = null;
                         } else {
                             this.musetalkWebSocket = null;
                         }
                     };
                     
                                           serverWebSocket.onerror = (error) => {
                          clearTimeout(connectionTimeout);
                          console.error(`WebSocket error for ${serverName}:`, error);
                          this.showMessage(`Failed to connect to ${serverName} (${wsUrl})`, 'error');
                         
                         button.textContent = serverNumber === 1 ? 'Connect Mini Omni 2' : 'Connect Musetalk';
                         button.disabled = false;
                     };

                 } catch (error) {
                     console.error(`Error connecting to ${serverName}:`, error);
                     this.showMessage(`Failed to connect to ${serverName}: ${error.message}`, 'error');
                     
                     const button = serverNumber === 1 ? this.connectServer1Btn : this.connectServer2Btn;
                     button.textContent = serverNumber === 1 ? 'Connect Mini Omni 2' : 'Connect Musetalk';
                     button.disabled = false;
                 }
             }

                           handleServerMessage(data, serverName) {
                  console.log(`Message from ${serverName}:`, data);
                  
                  // Handle different message types from the servers
                  switch (data.type) {
                      case 'init_ack':
                          this.showMessage(`${serverName} acknowledged connection`, 'success');
                          break;
                      case 'status':
                          this.showMessage(`${serverName} status: ${data.message}`, 'info');
                          break;
                      case 'error':
                          this.showMessage(`${serverName} error: ${data.message}`, 'error');
                          break;
                      case 'audio_processing_response':
                          if (serverName === 'Mini Omni 2') {
                              this.handleMiniOmni2ProcessingResponse(data);
                          }
                          break;
                      case 'processing_complete':
                          if (serverName === 'Mini Omni 2') {
                              this.showMessage(`Mini Omni 2 processing complete: ${data.message || 'Audio processed successfully'}`, 'success');
                          }
                          break;
                      case 'processing_error':
                          if (serverName === 'Mini Omni 2') {
                              this.showMessage(`Mini Omni 2 processing error: ${data.message}`, 'error');
                          }
                          break;
                      default:
                          console.log(`Unknown message type from ${serverName}:`, data);
                  }
              }
              
              handleMiniOmni2ProcessingResponse(data) {
                  // Handle processing response from Mini Omni 2
                  if (data.status === 'processing') {
                      this.showMessage(`Mini Omni 2: Processing audio (${data.progress || 0}%)`, 'info');
                  } else if (data.status === 'complete') {
                      this.showMessage(`Mini Omni 2: Processing complete!`, 'success');
                      
                      // If there's processed audio data, you could handle it here
                      if (data.processed_audio) {
                          console.log('Received processed audio from Mini Omni 2');
                          // Handle the processed audio data as needed
                      }
                  } else if (data.status === 'error') {
                      this.showMessage(`Mini Omni 2 processing failed: ${data.error}`, 'error');
                  }
              }

                         disconnectAllServers() {
                 // Close Mini Omni 2 WebSocket connection
                 if (this.miniOmniWebSocket) {
                     this.miniOmniWebSocket.close(1000, 'User disconnected');
                     this.miniOmniWebSocket = null;
                 }
                 
                 // Close Musetalk WebSocket connection
                 if (this.musetalkWebSocket) {
                     this.musetalkWebSocket.close(1000, 'User disconnected');
                     this.musetalkWebSocket = null;
                 }
                 
                 // Reset all server connection buttons
                 this.connectServer1Btn.textContent = 'Connect Mini Omni 2';
                 this.connectServer1Btn.disabled = false;
                 this.connectServer1Btn.style.background = '';

                 this.connectServer2Btn.textContent = 'Connect Musetalk';
                 this.connectServer2Btn.disabled = false;
                 this.connectServer2Btn.style.background = '';

                 this.showMessage('Disconnected from all servers', 'info');
             }
        }

        // Initialize the audio recorder when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new WebRTCAudioRecorder();
        });
    </script>
</body>
</html>
